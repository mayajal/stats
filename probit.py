# -*- coding: utf-8 -*-
"""Probit-Logit-updated.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1En7ewg1BD_InatOcHe2R9S4BzHfJntkN
"""

#Code to conduct Probit statistics for toxicological experiments.
# Import necessary libraries
import matplotlib.pyplot as plt  # For plotting
import numpy as np  # For numerical operations
from scipy.stats import linregress, norm, chi2  # For statistical computations
import pandas as pd  # For data manipulation
import statsmodels.api as sm  # For statistical modeling
import seaborn as sns  # For enhanced visualization

# Define experimental data (CONC: Concentration, N: Total individuals, DEAD: Number of dead individuals)
data = {
    'CONC': [1,3,5,7,10,15],
    'N': [30,30,30,30,30,30],
    'DEAD': [4,13,22,24,30,30]
}

# Generate binary response data for each concentration level
response_list = []
for i in range(len(data['CONC'])):
    dead_count = data['DEAD'][i]
    alive_count = data['N'][i] - dead_count
    response_list.extend([1] * dead_count + [0] * alive_count)

# Create a dataframe with repeated concentration levels and binary responses
df = pd.DataFrame({
    'CONC': np.repeat(data['CONC'], data['N']),
    'DEAD': response_list
})

# Add a constant term for the intercept in the regression model
df['const'] = 1

# Fit the logit model using statsmodels
X = df[['const', 'CONC']]
y = df['DEAD']
model = sm.Logit(y, X)
result = model.fit()

# Display the summary of the logit model
print(result.summary())

# Transform 'CONC' to log scale and predict logits for each concentration level
df['log_CONC'] = np.log10(df['CONC'])
df['predicted_logits'] = result.predict()

# Calculate goodness of fit measures (Deviance Chi-Square and p-value)
deviance_residuals = result.resid_dev
deviance_chi_square = np.sum(deviance_residuals**2)
p_value = 1 - chi2.cdf(deviance_chi_square, df=result.df_resid)
print(f'Deviance Chi-Square: {deviance_chi_square:.4f}')
print(f'Goodness of Fit p-value: {p_value:.4f}')

# Calculate linear regression between log(CONC) and predicted logits
slope, intercept, r_value, p_value, std_err = linregress(df['log_CONC'], df['predicted_logits'])
regression_equation = f'y = {slope:.4f} * x + {intercept:.4f}'
print('Regression Equation (log scale):', regression_equation)

# Calculate 'CONC' values corresponding to specified probit levels
probit_levels = [0.25,0.5, 0.95, 0.99]
conc_values = {}
conf_intervals = {}

for probit_level in probit_levels:
    # Calculate 'CONC' value using back-transformed regression equation
    conc_value = 10 ** ((probit_level - intercept) / slope)
    conc_values[f'CONC_{int(probit_level * 100)}'] = conc_value

    # Calculate confidence intervals at 95% confidence interval
    stderr_margin = norm.ppf(0.975) * std_err
    lower_bound = 10 ** ((probit_level - intercept - stderr_margin) / slope)
    upper_bound = 10 ** ((probit_level - intercept + stderr_margin) / slope)
    conf_intervals[f'CONC_{int(probit_level * 100)}'] = (lower_bound, upper_bound)

# Display the calculated 'CONC' values and confidence intervals
for level, value in conc_values.items():
   print(f'{level}: {value:.4f}')

for level, interval in conf_intervals.items():
   print(f'{level} 95% Confidence Interval: ({interval[0]:.4f}, {interval[1]:.4f})')

# Plot log10 of 'CONC' against 'predicted_logits'
plt.scatter(df['log_CONC'], df['predicted_logits'], label='Logit Model')
plt.title('Logit Model: log10(CONC) vs Mortality proportion logits')
sns.regplot(x='log_CONC', y='predicted_logits',data=df)  # Add regression line
plt.show()
